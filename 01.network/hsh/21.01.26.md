# 21.01.26

## 주요 질문

#### 💡 로드 밸런싱(Load Balancing)에 대해 설명하시오.
   * 여러 서버에게 균등하게 트래픽을 분산시켜주는 것이 바로 로드 밸런싱이다.
   * 로드 밸런싱은 분산식 웹 서비스로, 여러 서버에 부하(Load)를 나누어주는 역할을 한다. Load Balancer를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산시켜주는 방식이다. 서비스를 운영하는 사이트의 규모에 따라 웹 서버를 추가로 증설하면서 로드 밸런서로 관리해주면 웹 서버의 부하를 해결할 수 있다.
   <img src = "https://camo.githubusercontent.com/b59f02d63a1372b35abffa94e241b9b8d27447f3/68747470733a2f2f7777772e6564756361746976652e696f2f6170692f636f6c6c656374696f6e2f353636383633393130313431393532302f353634393035303232353334343531322f706167652f353734373937363230373037333238302f696d6167652f353639363435393134383039393538342e706e67">

   * 로드 밸런서가 서버를 선택하는 방식
     1. 라운드 로빈(Round Robin) : CPU 스케줄링의 라운드 로빈 방식 활용
     2. Least Connections : 연결 개수가 가장 적은 서버 선택 (트래픽으로 인해 세션이 길어지는 경우 권장)
     3. Source : 사용자 IP를 해싱하여 분배 (특정 사용자가 항상 같은 서버로 연결되는 것 보장)

     
#### 💡 [Blocking vs Non-Blocking model](#blcokingnon-blocking)
   * Blocking model은 I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기하는 방식이다. Non-Blocking model은 blocking 방식의 비효율성을 극복하고자 도입된 방식이다. I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식이다.

#### 💡 [CORS(Cross Origin Resource Sharing)가 왜 필요한가요?](#corscross-origin-resource-sharing)
   * 만약 내가 서비스하고 있지 않은 사이트에서 세션을 요청해서 세션을 획득할 수 있다면 해당 사이트는 악의적으로 내 세션을 탈취하거나 다른 행동을 할 수 있습니다. 그래서 브라우저에서는 이러한 요청을 막습니다. 피싱사이트가 대표적인 공격 사례인데 이러한 것을 막고 내가 허용한 origin들만 요청할 수 있도록 하기 위해 필요합니다.

#### 💡 [웹소켓 이전의 양방향 통신 기법은 어떤것이 있는가?](#양방향-통신)
   * Polling, long Polling, Streaming 세개의 방식이 존재한다.

#### 💡 [웹소켓 (WebScoket)이란?](#web-socket)
   * WebSocket은 한줄로 요약하면 Web이라는 요청과 응답이라는 제약적인 환경에 벗어나, Socket을 통한 지속적인 통신을 가능만드는 것이라고 표현할 수 있습니다. 

## 개념 정리

### Blcoking,Non-Blocking

   * I/O 작업
      - 먼저 I/O 용어는 Input/Output의 약자로 알고 있을 것이다. 주로 파일 입출력을 다룰 때 흔히 볼 수 있다. 네트워크에서도 쉽게 볼 수 있는데 예를 들어, 소켓의 read/send를 생각하면 이해가 갈 것이다.

      - 두 대 이상의 컴퓨터끼리 서로 네트워크를 통해 통신을 한다고 가정할 때,
      한 컴퓨터에서 출력(send)을 하고, 다른 한 컴퓨터에서 입력(read)을 받는 과정을 통해 통신을 할 수 있다.

      - I/O 작업은 User(유저 레벨)에서 직접 수행할 수 없고, 실제 IO 작업을 수행하는 것은 Kernel(커널 레벨)에서만 가능하다.
      유저 프로세스(또는 스레드)는 커널에게 요청을 하고 작업 완료 후 커널이 반환하는 결과를 기다릴 뿐이다.

   * Blocking Model
      - 가장 기본적인 I/O 모델로, linux에서 모든 소켓 통신은 기본 blocking으로 동작한다. I/O 작업이 진행되는 동안 유저 프로세스는 자신의 작업을 중단한 채 대기하는 방식이다.
      <img src ="https://user-images.githubusercontent.com/41428527/51266321-4ade9700-19fe-11e9-9b23-30bca4faccfd.png"><br>
      * 위의 그림처럼 유저는 커널에게(유저->커널) read작업을 요청하고 데이터가 입력될 때까지 대기하다가 데이터가 입력되면 유저에게(커널->유저) 결과가 전달되어야만 유저 자신의 작업에 비로소 복귀할 수 있다.

      * 말 그대로 block이 되고, 어플리케이션에서 다른 작업을 수행하지 못하고 대기하게 되므로 자원이 낭비된다.

   * Non-Blocking Model
     * 위와 같은 blocking 방식의 비효율성을 극복하고자 도입된 방식이다. I/O 작업이 진행되는 동안 유저 프로세스의 작업을 중단시키지 않는 방식이다.
     <img src = "https://user-images.githubusercontent.com/41428527/51266324-4e721e00-19fe-11e9-900a-809ff39e40c1.png"><br>
        1. 유저가 커널에게 (유저->커널) read작업을 요청하면
        2. 데이터가 입력이 됬든 안됬든 요청하는 그 순간, 바로 결과가 반환된다.이 때, 입력 데이터가 없으면 입력 데이터가 없다는 결과 메세지(EWOULDBLOCK)를 반환한다.
        3. 입력 데이터가 있을 때 까지 1-2번 반복. (2번에서 결과 메세지를 받은 유저는 다른 작업 진행이 가능하다.)
        4. 입력 데이터가 있으면 유저에게(커널->유저) 결과가 전달된다.
      * 이 경우 I/O의 진행시간과 관계가 없기 때문에(대기x) 어플리케이션에서 작업을 오랜 시간 중지하지 않고도 I/O 작업을 진행할 수 있다. 그러나 반복적으로 시스템 호출이 발생하기 때문에 이 경우 역시 자원이 낭비된다.

 ### CORS(Cross Origin Resource Sharing)
   * Cross-Origin Resource Sharing(CORS)은 추가적인 HTTP header를 사용해서 애플리케이션이 다른 origin의 리소스에 접근할 수 있도록 하는 메커니즘을 말합니다. 하지만 다른 origin에서 내 리소스에 함부로 접근하지 못하게 하기 위해 사용된다.

   * 브라우저가 리소스를 요청할 때 추가적인 헤더에 정보를 담습니다. 내 origin은 무엇이고 어떤 메소드를 사용해서 요청을 할 것이고 어떤 헤더들을 포함할 것인지를 담아서 서버에 전송합니다. 서버는 서버가 응답할 수 있는 origin들을 헤더에 담아서 브라우저에게 보냅니다. 브라우저가 이 헤더를 보고 해당 origin에서 요청할 수 있다면 리소스 전송을 허용하고 만약 불가능하다면 에러를 발생시킵니다.
   ```
   Origin이란?
      - 도메인(domain): naver.com
      - 오리진(origin): https://www.naver.com/PORT
      - 이와 같이 도메인과 오리진의 차이는 프로토콜과 포트번호의 포함 여부이다.
   ```


### 양방향 통신
   * http의 단점
     * http는 절대 절대 절대 양방향이 되지 않는다.
     * http는 서버에서 원하는 타이밍에 클라이언트에게 데이터를 보낼 수 없다.
   * webSocket은 웹페이지와 서버간에 실시간 상호작용을 위해 만들어진 스팩이다.

   * http 규격 자체가 클라이언트에서 서버로의 단방향 통신을 위해 만들어진 방법으로, webSocket 이전에는 실시간 통신을 위해서 일반 http request에 약간의 트릭을 사용해서 실시간인것 처럼 작동하게 하는 아래와 같은 기술들이 있었다.

   1. **polling**
      <img src = "https://t1.daumcdn.net/cfile/tistory/993027435C28B49603" width="70%" height="70%"><br>
      * 클라이언트가 평범한 http request를 서버로 계속 날려서 이벤트 내용을 전달받는 방식이다. 가장 쉬운방법이지만 클라이언트가 계속적으로 request를 날리기때문에 클라이언가 많아지면 서버의 부담이 급증하게 된다. http request connection을 맺고 끊는것 자체가 부담이 많은 방식이다. 그럼에도 불구하고 클라이언트에서 실시간정도의 빠른 응답을 기대하기도 어렵다.

      * http polling의 특징
        1. 주기적으로 물어보므로 응답 간격을 일정하게 할 수 있다.
        2. 주기적으로 몰아서 물어보는게 가능하므로 자동으로 배치프로세싱(일괄처리)되어서 db튜닝을 하는 효과가 나온다.
        3. 실시간으로 주는건 불가능하다. 실시간 효과를 내려면 간격을 줄여야 하지만 서버와 클라이언트 모두에게 부담이다.
        4. 보낼데이터가 없어도 계속해서 데이터를 줘야하므로 서버의 리소스를 낭비하게된다.
     

   
   2. **long polling**
      <img src = "https://t1.daumcdn.net/cfile/tistory/99A9F74C5C28BF1A2A" width="70%" height="70%"><br>
      *  차이점이 있다면 일반 polling은 주기적으로 물어본다면, long polling은 일단 보내고 time out될 때까지 무한정 기다린다는 것이다.
      * http long polling의 특징
        1. 항상 연결이 유지 되어 있다.
        2. 변경에 매우 민감하게 반응한다. 사실상 실시간으로 통신이 가능하다.
        3. 데이터가 주어지는 즉시 바로바로 반응하고 보내므로 요청간격이 줄어든다면 polling보다 훨씬 데이터를 많이 보내게된다.


   3. **Streaming**
      * 요청에 대한 응답을 완료하지 않은 상태에서 데이터를 계속 내려받는 방식.
      * 응답마다 다시 요청해야 하는 Long Polling에 비해 효율적이며, 서버의 상태 변경이 잦은 경우에 유리하다.
      * 연결을 길게 맺고 있는 경우 유효성 관리 등의 부담이 발생한다.
         : 스트리밍 방식도 보통 특정 주기로 연결을 재설정하도록 구현한다.

### Web-socket
   * 꼼수에서 벗어나 정식으로 클라이언트 서버간 양방향 통신이 가능하게 하기 위해서 HTML5 표준의 일부로 webSocket이 만들어지게 되었다.
   * webSocket이 기존의 일반 TCP Socket과 다른 점은 최초 접속이 일반 http request를 통해 handshaking과정을 통해 이루어 진다는 점이다. http request를 그대로 사용하기 때문에 기존의 80, 443 포트로 접속을 하므로 추가로 방화벽을 열지 않고도 양방향 통신이 가능하고, http 규격인 CORS적용이나 인증등의 과정을 기존과 동일하게 가저갈 수 있는것이 장점이다.
   * 웹 소켓은 클라이언트와 서버간의 전이중 통신을 지원하기 위한 통신 프로토콜이다. 웹 소켓은 다음과 방식으로 동작한다.
   <img src = "https://t1.daumcdn.net/cfile/tistory/99C87F335C79684D1D"><br>

   1. 클라이언트와 서버간에 전이중 통신을 수행하려면 클라이언트가 서버로 HTTP UPGRADE 요청을 보내야 한다. 이를 웹 소켓 프로토콜 핸드 쉐이크라고한다.
   2. 서버가 커넥션을 UPGRADE 할 수 있는 경우,  HTTP 101 응답을 클라이언트에게 보낸다. 서버는 핸드 쉐이크가 성공적으로 수행되었다고 판단하고, 서버와 클라이언트 사이의 커넥션을 웹 소켓 프로토콜로 UPGRADE 한다. 클라이언트와 서버 사이의 HTTP 101 응답이 전달되는 순간, 서버와 클라이언트 사이의 커넥션은 HTTP 프로토콜이라고 하지 않는다. 그리고 이순간 양방향 통신이 가능해진다.
   3. 웹 소켓으로 연결된 모든 클라이언트는 다른 클라이언트에게 커넥션을 끊는 요청을 전송할 수 있다.
   
   * Socket.io(http://socket.io)
      * node.js 기반으로 만들어진 기술로 자체 스팩으로 만들어진 socket.io 서버를 만들고 socket.io 클라이언트와 브라우저에 구애받지 않고 실시간 통신이 가능해진다. socket.io는 node.js 기반이기때문에 모든 코드가 javascript로 작성되어 있다. 서버, 클라이언트 모두 javascript 기반으로 개발하는 것이 기본이다. 그러다보니 자바 개발자들은 socket.io를 쓸 수 없다. 자바로 개발이 가능하게 해주는 방법이 몇가지 있긴한 것 같지만 역시 javascript 기반 솔루션은 javascript로 개발해야 문제발생을 줄일 수 있을 것이다.


   <details markdown="1">
      <summary>출처</summary>
      [1] : https://kamang-it.tistory.com/entry/Webhttp%ED%86%B5%EC%8B%A0%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%96%91%EB%B0%A9%ED%96%A5-%ED%86%B5%EC%8B%A0%EA%B8%B0%EB%B2%95-long-polling <br>
      [2] : https://m.blog.naver.com/PostView.nhn?blogId=youreme&logNo=110162110369&proxyReferer=https:%2F%2Fwww.google.com%2F
      [3] : https://lkhlkh23.tistory.com/121
  </details>
